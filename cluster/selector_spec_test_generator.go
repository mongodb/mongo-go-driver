// +build ignore

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"html/template"
	"io/ioutil"
	"log"
	"path"
	"strings"

	"gopkg.in/yaml.v2"
)

func main() {
	log.SetFlags(0)
	log.SetPrefix(name + ": ")

	var g Generator

	g.printlnf("// Code generated by \"%s.go\"; DO NOT EDIT\n", name)

	src := g.generate()

	err := ioutil.WriteFile(fmt.Sprintf("%s.go", strings.TrimSuffix(name, "_generator")), src, 0644)
	if err != nil {
		log.Fatalf("writing output: %s", err)
	}
}

// Generator holds the state of the analysis. Primarily used to buffer
// the output for format.Source.
type Generator struct {
	buf bytes.Buffer // Accumulated output.
}

// format returns the gofmt-ed contents of the Generator's buffer.
func (g *Generator) format() []byte {
	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		// Should never happen, but can arise when developing this code.
		// The user can compile the output to see the error.
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		log.Printf("warning: compile the package to analyze the error")
		return g.buf.Bytes()
	}
	return src
}

func (g *Generator) printf(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, format, args...)
}

func (g *Generator) printlnf(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, format+"\n", args...)
}

// EVERYTHING ABOVE IS CONSTANT BETWEEN THE GENERATORS

const name = "selector_spec_test_generator"

func (g *Generator) generate() []byte {

	testsDir := "../specifications/source/server-selection/tests/server_selection/"

	var tests []*testDef

	entries, err := ioutil.ReadDir(testsDir)
	if err != nil {
		log.Fatalf("error reading directory %q: %s", testsDir, err)
	}

	for _, entry := range entries {
		if !entry.IsDir() {
			continue
		}

		subDir := path.Join(testsDir, entry.Name())

		subentries, err := ioutil.ReadDir(subDir)
		if err != nil {
			log.Fatalf("error reading directory %q: %s", subDir, err)
		}

		for _, subentry := range subentries {
			if !subentry.IsDir() || subentry.Name() == "write" {
				continue
			}

			subentryDir := path.Join(subDir, subentry.Name())

			testEntries, err := ioutil.ReadDir(subentryDir)
			if err != nil {
				log.Fatalf("error reading directory %q: %s", subentryDir, err)
			}

			for _, testentry := range testEntries {
				if path.Ext(testentry.Name()) != ".yml" || strings.HasPrefix(testentry.Name(), "PossiblePrimary") {
					continue
				}
				testFile := path.Join(subentryDir, testentry.Name())
				test, err := g.loadTest(testFile)
				if err != nil {
					log.Fatalf("error loading test from file %q: %s", testFile, err)
				}
				test.Name = fmt.Sprintf("%s_%s_%s", entry.Name(), subentry.Name(), testentry.Name()[:len(testentry.Name())-4])
				tests = append(tests, test)
			}
		}
	}

	tmpl, err := g.getTemplate()
	if err != nil {
		log.Fatalf("error loading template: %s", err)
	}

	tmpl.Execute(&g.buf, tests)

	return g.format()
}

func (g *Generator) loadTest(filename string) (*testDef, error) {
	content, err := ioutil.ReadFile(filename)
	if err != nil {
		return nil, err
	}

	var testDef testDef
	err = yaml.Unmarshal(content, &testDef)
	if err != nil {
		return nil, err
	}

	return &testDef, nil
}

func (g *Generator) getTemplate() (*template.Template, error) {
	content := `package cluster_test

import (
	"testing"
	"time"

   	"github.com/stretchr/testify/require"

    . "github.com/10gen/mongo-go-driver/cluster"
	"github.com/10gen/mongo-go-driver/conn"
    "github.com/10gen/mongo-go-driver/readpref"
    "github.com/10gen/mongo-go-driver/server"
)
{{range .}}
func TestReadPref_{{.Name}}(t *testing.T) {
	t.Parallel()
	
	require := require.New(t)
    subject := readpref.New(readpref.{{.ReadPreference.Mode}}Mode,
        readpref.WithTagSets({{range .ReadPreference.TagSets}}
			server.NewTagSet({{range $key, $value := .}}
				"{{$key}}", "{{$value}}",
			{{end}}),
        {{end}}),
	)

	{{with .TopologyDescription}}
    c := &Desc{
        Type: {{.Type}},
        Servers: []*server.Desc{
        {{range .Servers}}  &server.Desc{
				AverageRTT: time.Duration({{.AverageRTTMS}})*time.Millisecond,
				AverageRTTSet: true,
                Endpoint: conn.Endpoint("{{.Address}}"),
                Type: server.{{.Type}},
                Tags: server.NewTagSet({{range $key, $value := .Tags}}
                    "{{$key}}", "{{$value}}",
                {{end}}),
            },
            {{end}}
        },
    }
	{{end}}

	readPrefSelector := ReadPrefSelector(subject)
    result, err := readPrefSelector(c, c.Servers)
    require.NoError(err)
    require.Len(result, {{ len .SuitableServers }})
	{{ range .SuitableServers }}require.Contains(
		result,
		&server.Desc{
			Endpoint: conn.Endpoint("{{.Address}}"),
			AverageRTT: time.Duration({{.AverageRTTMS}})*time.Millisecond,
			AverageRTTSet: true,
			Type: server.{{.Type}},
			Tags: server.NewTagSet({{range $key, $value := .Tags}}
				"{{$key}}", "{{$value}}",
			{{end}}),
		},
	)
	{{end}}

	latencySelector := LatencySelector(time.Duration(15)*time.Millisecond)
	result, err = CompositeSelector([]ServerSelector{readPrefSelector, latencySelector})(c, c.Servers)
    require.NoError(err)
    require.Len(result, {{ len .InLatencyWindow }})
	{{ range .InLatencyWindow }}require.Contains(
		result,
		&server.Desc{
			Endpoint: conn.Endpoint("{{.Address}}"),
			AverageRTT: time.Duration({{.AverageRTTMS}})*time.Millisecond,
			AverageRTTSet: true,
			Type: server.{{.Type}},
			Tags: server.NewTagSet({{range $key, $value := .Tags}}
				"{{$key}}", "{{$value}}",
			{{end}}),
		},
	)
	{{end}}}
{{end}}
`
	tmpl, err := template.New("").Parse(content)
	if err != nil {
		return nil, err
	}
	return tmpl, nil
}

type testDef struct {
	Name string

	TopologyDescription topDesc      `yaml:"topology_description"`
	Operation           string       `yaml:"operation"`
	ReadPreference      readPref     `yaml:"read_preference"`
	SuitableServers     []serverDesc `yaml:"suitable_servers"`
	InLatencyWindow     []serverDesc `yaml:"in_latency_window"`
}

type topDesc struct {
	Type    string       `yaml:"type"`
	Servers []serverDesc `yaml:"servers"`
}

type serverDesc struct {
	Address      string            `yaml:"address"`
	AverageRTTMS int               `yaml:"avg_rtt_ms"`
	Type         string            `yaml:"type"`
	Tags         map[string]string `yaml:"tags"`
}

type readPref struct {
	Mode    string              `yaml:"mode"`
	TagSets []map[string]string `yaml:"tag_sets"`
}
